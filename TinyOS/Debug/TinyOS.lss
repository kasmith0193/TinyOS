
TinyOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000028e  00800100  000007ca  0000085e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000007ca  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000c  0080038e  0080038e  00000aec  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000aec  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000b1c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000b0  00000000  00000000  00000b60  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001053  00000000  00000000  00000c10  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000717  00000000  00000000  00001c63  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b73  00000000  00000000  0000237a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000134  00000000  00000000  00002ef0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000041a  00000000  00000000  00003024  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000167  00000000  00000000  0000343e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000080  00000000  00000000  000035a5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	13 e0       	ldi	r17, 0x03	; 3
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ea ec       	ldi	r30, 0xCA	; 202
  7c:	f7 e0       	ldi	r31, 0x07	; 7
  7e:	02 c0       	rjmp	.+4      	; 0x84 <DIDR1+0x5>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ae 38       	cpi	r26, 0x8E	; 142
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <DIDR1+0x1>

0000008a <__do_clear_bss>:
  8a:	23 e0       	ldi	r18, 0x03	; 3
  8c:	ae e8       	ldi	r26, 0x8E	; 142
  8e:	b3 e0       	ldi	r27, 0x03	; 3
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	aa 39       	cpi	r26, 0x9A	; 154
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 b4 03 	call	0x768	; 0x768 <main>
  9e:	0c 94 e3 03 	jmp	0x7c6	; 0x7c6 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <Mega328P_Init>:
.set	temp,0				//student comment here

.section ".text"			//student comment here
.global Mega328P_Init
Mega328P_Init:
		ldi	r16,0x07		;PB0(R*W),PB1(RS),PB2(E) as fixed outputs
  a6:	07 e0       	ldi	r16, 0x07	; 7
		out	DDRB,r16		//student comment here
  a8:	04 b9       	out	0x04, r16	; 4
		ldi	r16,0			//student comment here
  aa:	00 e0       	ldi	r16, 0x00	; 0
		out	PORTB,r16		//student comment here
  ac:	05 b9       	out	0x05, r16	; 5
		out	U2X0,r16		;initialize UART, 8bits, no parity, 1 stop, 9600
  ae:	01 b9       	out	0x01, r16	; 1
		ldi	r17,0x0			//student comment here
  b0:	10 e0       	ldi	r17, 0x00	; 0
		ldi	r16,0x67		//student comment here
  b2:	07 e6       	ldi	r16, 0x67	; 103
		sts	UBRR0H,r17		//student comment here
  b4:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts	UBRR0L,r16		//student comment here
  b8:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ldi	r16,24			//student comment here
  bc:	08 e1       	ldi	r16, 0x18	; 24
		sts	UCSR0B,r16		//student comment here
  be:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		ldi	r16,6			//student comment here
  c2:	06 e0       	ldi	r16, 0x06	; 6
		sts	UCSR0C,r16		//student comment here
  c4:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		ldi r16,0x87		//initialize ADC
  c8:	07 e8       	ldi	r16, 0x87	; 135
		sts	ADCSRA,r16		//student comment here
  ca:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		ldi r16,0x40		//student comment here
  ce:	00 e4       	ldi	r16, 0x40	; 64
		sts ADMUX,r16		//student comment here
  d0:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
		ldi r16,0			//student comment here
  d4:	00 e0       	ldi	r16, 0x00	; 0
		sts ADCSRB,r16		//student comment here
  d6:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		ldi r16,0xFE		//student comment here
  da:	0e ef       	ldi	r16, 0xFE	; 254
		sts DIDR0,r16		//student comment here
  dc:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
		ldi r16,0xFF		//student comment here
  e0:	0f ef       	ldi	r16, 0xFF	; 255
		sts DIDR1,r16		//student comment here
  e2:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
		ret					//student comment here
  e6:	08 95       	ret

000000e8 <LCD_Write_Command>:
	
.global LCD_Write_Command
LCD_Write_Command:
	call	UART_Off		//student comment here
  e8:	0e 94 b1 00 	call	0x162	; 0x162 <UART_Off>
	ldi		r16,0xFF		;PD0 - PD7 as outputs
  ec:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
  ee:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
  f0:	00 91 8e 03 	lds	r16, 0x038E	; 0x80038e <__data_end>
	out		PORTD,r16		//student comment here
  f4:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,4			//student comment here
  f6:	04 e0       	ldi	r16, 0x04	; 4
	out		PORTB,r16		//student comment here
  f8:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
  fa:	0e 94 86 00 	call	0x10c	; 0x10c <LCD_Delay>
	ldi		r16,0			//student comment here
  fe:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 100:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 102:	0e 94 86 00 	call	0x10c	; 0x10c <LCD_Delay>
	call	UART_On			//student comment here
 106:	0e 94 ab 00 	call	0x156	; 0x156 <UART_On>
	ret						//student comment here
 10a:	08 95       	ret

0000010c <LCD_Delay>:

.global LCD_Delay
LCD_Delay:
	ldi		r16,0xFA		//student comment here
 10c:	0a ef       	ldi	r16, 0xFA	; 250

0000010e <D0>:
D0:	ldi		r17,0xFF		//student comment here
 10e:	1f ef       	ldi	r17, 0xFF	; 255

00000110 <D1>:
D1:	dec		r17				//student comment here
 110:	1a 95       	dec	r17
	brne	D1				//student comment here
 112:	f1 f7       	brne	.-4      	; 0x110 <D1>
	dec		r16				//student comment here
 114:	0a 95       	dec	r16
	brne	D0				//student comment here
 116:	d9 f7       	brne	.-10     	; 0x10e <D0>
	ret						//student comment here
 118:	08 95       	ret

0000011a <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
	call	UART_Off		//student comment here
 11a:	0e 94 b1 00 	call	0x162	; 0x162 <UART_Off>
	ldi		r16,0xFF		//student comment here
 11e:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 120:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 122:	00 91 8e 03 	lds	r16, 0x038E	; 0x80038e <__data_end>
	out		PORTD,r16		//student comment here
 126:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,6			//student comment here
 128:	06 e0       	ldi	r16, 0x06	; 6
	out		PORTB,r16		//student comment here
 12a:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 12c:	0e 94 86 00 	call	0x10c	; 0x10c <LCD_Delay>
	ldi		r16,0			//student comment here
 130:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 132:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 134:	0e 94 86 00 	call	0x10c	; 0x10c <LCD_Delay>
	call	UART_On			//student comment here
 138:	0e 94 ab 00 	call	0x156	; 0x156 <UART_On>
	ret						//student comment here
 13c:	08 95       	ret

0000013e <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
	call	UART_Off		//student comment here
 13e:	0e 94 b1 00 	call	0x162	; 0x162 <UART_Off>
	ldi		r16,0x00		//student comment here
 142:	00 e0       	ldi	r16, 0x00	; 0
	out		DDRD,r16		//student comment here
 144:	0a b9       	out	0x0a, r16	; 10
	out		PORTB,4			//student comment here
 146:	45 b8       	out	0x05, r4	; 5
	in		r16,PORTD		//student comment here
 148:	0b b1       	in	r16, 0x0b	; 11
	sts		DATA,r16		//student comment here
 14a:	00 93 8e 03 	sts	0x038E, r16	; 0x80038e <__data_end>
	out		PORTB,0			//student comment here
 14e:	05 b8       	out	0x05, r0	; 5
	call	UART_On			//student comment here
 150:	0e 94 ab 00 	call	0x156	; 0x156 <UART_On>
	ret						//student comment here
 154:	08 95       	ret

00000156 <UART_On>:

.global UART_On
UART_On:
	ldi		r16,2				//student comment here
 156:	02 e0       	ldi	r16, 0x02	; 2
	out		DDRD,r16			//student comment here
 158:	0a b9       	out	0x0a, r16	; 10
	ldi		r16,24				//student comment here
 15a:	08 e1       	ldi	r16, 0x18	; 24
	sts		UCSR0B,r16			//student comment here
 15c:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret							//student comment here
 160:	08 95       	ret

00000162 <UART_Off>:

.global UART_Off
UART_Off:
	ldi	r16,0					//student comment here
 162:	00 e0       	ldi	r16, 0x00	; 0
	sts UCSR0B,r16				//student comment here
 164:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret							//student comment here
 168:	08 95       	ret

0000016a <UART_Clear>:

.global UART_Clear
UART_Clear:
	lds		r16,UCSR0A			//student comment here
 16a:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//student comment here
 16e:	07 ff       	sbrs	r16, 7
	ret							//student comment here
 170:	08 95       	ret
	lds		r16,UDR0			//student comment here
 172:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	rjmp	UART_Clear			//student comment here
 176:	f9 cf       	rjmp	.-14     	; 0x16a <UART_Clear>

00000178 <UART_Get>:

.global UART_Get
UART_Get:
	lds		r16,UCSR0A			//student comment here
 178:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//student comment here
 17c:	07 ff       	sbrs	r16, 7
	rjmp	UART_Get			//student comment here
 17e:	fc cf       	rjmp	.-8      	; 0x178 <UART_Get>
	lds		r16,UDR0			//student comment here
 180:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	sts		ASCII,r16			//student comment here
 184:	00 93 90 03 	sts	0x0390, r16	; 0x800390 <ASCII>
	ret							//student comment here
 188:	08 95       	ret

0000018a <UART_Inte>:

.global UART_Inte
UART_Inte:
	lds		r16,UCSR0A
 18a:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrc	r16,RXC0
 18e:	07 fd       	sbrc	r16, 7
	sts		ASCII,r16
 190:	00 93 90 03 	sts	0x0390, r16	; 0x800390 <ASCII>
	ret
 194:	08 95       	ret

00000196 <UART_Put>:

.global UART_Put
UART_Put:
	lds		r17,UCSR0A			//0xC0
 196:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r17,UDRE0			//0x05
 19a:	15 ff       	sbrs	r17, 5
	rjmp	UART_Put			//student comment here
 19c:	fc cf       	rjmp	.-8      	; 0x196 <UART_Put>
	lds		r16,ASCII			//student comment here
 19e:	00 91 90 03 	lds	r16, 0x0390	; 0x800390 <ASCII>
	sts		UDR0,r16			//student comment here
 1a2:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	ret							//student comment here
 1a6:	08 95       	ret

000001a8 <ADC_Get>:

.global ADC_Get
ADC_Get:
		ldi		r16,0xC7			//student comment here
 1a8:	07 ec       	ldi	r16, 0xC7	; 199
		sts		ADCSRA,r16			//student comment here
 1aa:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

000001ae <A2V1>:
A2V1:	lds		r16,ADCSRA			//student comment here
 1ae:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbrc	r16,ADSC			//student comment here
 1b2:	06 fd       	sbrc	r16, 6
		rjmp 	A2V1				//student comment here
 1b4:	fc cf       	rjmp	.-8      	; 0x1ae <A2V1>
		lds		r16,ADCL			//student comment here
 1b6:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
		sts		LADC,r16			//student comment here
 1ba:	00 93 97 03 	sts	0x0397, r16	; 0x800397 <LADC>
		lds		r16,ADCH			//student comment here
 1be:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
		sts		HADC,r16			//student comment here
 1c2:	00 93 8f 03 	sts	0x038F, r16	; 0x80038f <HADC>
		ret							//student comment here
 1c6:	08 95       	ret

000001c8 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
		sbic    EECR,EEPE
 1c8:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Write		; Wait for completion of previous write
 1ca:	fe cf       	rjmp	.-4      	; 0x1c8 <EEPROM_Write>
		ldi		r18,0x00			; Set up address (r18:r17) in address register
 1cc:	20 e0       	ldi	r18, 0x00	; 0
		lds		r17,EEPROMAL 
 1ce:	10 91 91 03 	lds	r17, 0x0391	; 0x800391 <EEPROMAL>
		lds		r16, ASCII			; Set up data in r16    
 1d2:	00 91 90 03 	lds	r16, 0x0390	; 0x800390 <ASCII>
		out     EEARH, r18      
 1d6:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17			      
 1d8:	11 bd       	out	0x21, r17	; 33
		out     EEDR,r16			; Write data (r16) to Data Register  
 1da:	00 bd       	out	0x20, r16	; 32
		sbi     EECR,EEMPE			; Write logical one to EEMPE
 1dc:	fa 9a       	sbi	0x1f, 2	; 31
		sbi     EECR,EEPE			; Start eeprom write by setting EEPE
 1de:	f9 9a       	sbi	0x1f, 1	; 31
		ret 
 1e0:	08 95       	ret

000001e2 <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
		sbic    EECR,EEPE    
 1e2:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Read			; Wait for completion of previous write
 1e4:	fe cf       	rjmp	.-4      	; 0x1e2 <EEPROM_Read>
		ldi		r18,0x00			; Set up address (r18:r17) in EEPROM address register
 1e6:	20 e0       	ldi	r18, 0x00	; 0
		lds		r17,EEPROMAL
 1e8:	10 91 91 03 	lds	r17, 0x0391	; 0x800391 <EEPROMAL>
		ldi		r16,0x00   
 1ec:	00 e0       	ldi	r16, 0x00	; 0
		out     EEARH, r18   
 1ee:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17		   
 1f0:	11 bd       	out	0x21, r17	; 33
		sbi     EECR,EERE			; Start eeprom read by writing EERE
 1f2:	f8 9a       	sbi	0x1f, 0	; 31
		in      r16,EEDR			; Read data from Data Register
 1f4:	00 b5       	in	r16, 0x20	; 32
		sts		ASCII,r16  
 1f6:	00 93 90 03 	sts	0x0390, r16	; 0x800390 <ASCII>
		ret
 1fa:	08 95       	ret

000001fc <SetParity>:

.global SetParity
SetParity:
		call	UART_Off
 1fc:	0e 94 b1 00 	call	0x162	; 0x162 <UART_Off>
		lds		r16, UCSR0C
 200:	00 91 c2 00 	lds	r16, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		lds		r17, DATA
 204:	10 91 8e 03 	lds	r17, 0x038E	; 0x80038e <__data_end>
		ldi		r18, 0xff
 208:	2f ef       	ldi	r18, 0xFF	; 255
		or		r16, r17
 20a:	01 2b       	or	r16, r17
		eor		r17, r18
 20c:	12 27       	eor	r17, r18
		and		r16, r17
 20e:	01 23       	and	r16, r17
		sts		UCSR0C, r16
 210:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		call	UART_On
 214:	0e 94 ab 00 	call	0x156	; 0x156 <UART_On>
		ret
 218:	08 95       	ret

0000021a <SetDataBits>:

.global SetDataBits
SetDataBits:
		call	UART_Off
 21a:	0e 94 b1 00 	call	0x162	; 0x162 <UART_Off>
		lds		r16, UCSR0B
 21e:	00 91 c1 00 	lds	r16, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		lds		r17, UCSR0C
 222:	10 91 c2 00 	lds	r17, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		lds		r18, ASCII
 226:	20 91 90 03 	lds	r18, 0x0390	; 0x800390 <ASCII>
		cbr		r16, 0xfb
 22a:	04 70       	andi	r16, 0x04	; 4
		sbrc	r18, 0x3
 22c:	23 fd       	sbrc	r18, 3
		sbr		r16, 0x4
 22e:	04 60       	ori	r16, 0x04	; 4
		lds		r18, DATA
 230:	20 91 8e 03 	lds	r18, 0x038E	; 0x80038e <__data_end>
		cbr		r17, 0xfd
 234:	12 70       	andi	r17, 0x02	; 2
		cbr		r17, 0xfd
 236:	12 70       	andi	r17, 0x02	; 2
		add		r17, r18
 238:	12 0f       	add	r17, r18
		sts		UCSR0B,r16
 23a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		sts		UCSR0C,r17
 23e:	10 93 c2 00 	sts	0x00C2, r17	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		call	UART_On
 242:	0e 94 ab 00 	call	0x156	; 0x156 <UART_On>
		ret
 246:	08 95       	ret

00000248 <SetStop>:

.global SetStop
SetStop:
		call	UART_Off
 248:	0e 94 b1 00 	call	0x162	; 0x162 <UART_Off>
		lds		r16, ASCII
 24c:	00 91 90 03 	lds	r16, 0x0390	; 0x800390 <ASCII>
		lds		r17, UCSR0C
 250:	10 91 c2 00 	lds	r17, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		lsl		r16
 254:	00 0f       	add	r16, r16
		lsl		r16
 256:	00 0f       	add	r16, r16
		lsl		r16
 258:	00 0f       	add	r16, r16
		cbr		r17,0xf7
 25a:	18 70       	andi	r17, 0x08	; 8
		add		r17, r16
 25c:	10 0f       	add	r17, r16
		sts		UCSR0C, r17
 25e:	10 93 c2 00 	sts	0x00C2, r17	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		call	UART_On
 262:	0e 94 ab 00 	call	0x156	; 0x156 <UART_On>
		ret
 266:	08 95       	ret

00000268 <SetBaud>:

.global SetBaud
SetBaud:
		call	UART_Off
 268:	0e 94 b1 00 	call	0x162	; 0x162 <UART_Off>
		lds		r16, UBRR0H
 26c:	00 91 c5 00 	lds	r16, 0x00C5	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		lds		r17, ASCII
 270:	10 91 90 03 	lds	r17, 0x0390	; 0x800390 <ASCII>
		lds		r18, DATA
 274:	20 91 8e 03 	lds	r18, 0x038E	; 0x80038e <__data_end>
		swap	r18
 278:	22 95       	swap	r18
		mov		r19, r18
 27a:	32 2f       	mov	r19, r18
		cbr		r19, 0x0f
 27c:	30 7f       	andi	r19, 0xF0	; 240
		cbr		r16, 0xf0
 27e:	0f 70       	andi	r16, 0x0F	; 15
		add		r16, r19
 280:	03 0f       	add	r16, r19
		cbr		r18, 0xf0
 282:	2f 70       	andi	r18, 0x0F	; 15
		add		r17, r18
 284:	12 0f       	add	r17, r18
		sts		UBRR0H, r16
 286:	00 93 c5 00 	sts	0x00C5, r16	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts		UBRR0L, r17
 28a:	10 93 c4 00 	sts	0x00C4, r17	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		call	UART_On
 28e:	0e 94 ab 00 	call	0x156	; 0x156 <UART_On>
		ret
 292:	08 95       	ret

00000294 <UART_Puts>:

char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 294:	cf 93       	push	r28
 296:	df 93       	push	r29
 298:	ec 01       	movw	r28, r24
	while (*str)
 29a:	98 81       	ld	r25, Y
 29c:	99 23       	and	r25, r25
 29e:	41 f0       	breq	.+16     	; 0x2b0 <UART_Puts+0x1c>
 2a0:	21 96       	adiw	r28, 0x01	; 1
	{
		ASCII = *str++;
 2a2:	90 93 90 03 	sts	0x0390, r25	; 0x800390 <ASCII>
		UART_Put();
 2a6:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)
 2aa:	99 91       	ld	r25, Y+
 2ac:	91 11       	cpse	r25, r1
 2ae:	f9 cf       	rjmp	.-14     	; 0x2a2 <UART_Puts+0xe>
	{
		ASCII = *str++;
		UART_Put();
	}
}
 2b0:	df 91       	pop	r29
 2b2:	cf 91       	pop	r28
 2b4:	08 95       	ret

000002b6 <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 2b6:	cf 93       	push	r28
 2b8:	df 93       	push	r29
 2ba:	ec 01       	movw	r28, r24
	while (*str)
 2bc:	98 81       	ld	r25, Y
 2be:	99 23       	and	r25, r25
 2c0:	41 f0       	breq	.+16     	; 0x2d2 <LCD_Puts+0x1c>
 2c2:	21 96       	adiw	r28, 0x01	; 1
	{
		
		DATA = *str++;
 2c4:	90 93 8e 03 	sts	0x038E, r25	; 0x80038e <__data_end>
		LCD_Write_Data();
 2c8:	0e 94 8d 00 	call	0x11a	; 0x11a <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 2cc:	99 91       	ld	r25, Y+
 2ce:	91 11       	cpse	r25, r1
 2d0:	f9 cf       	rjmp	.-14     	; 0x2c4 <LCD_Puts+0xe>
	{
		
		DATA = *str++;
		LCD_Write_Data();
	}
}
 2d2:	df 91       	pop	r29
 2d4:	cf 91       	pop	r28
 2d6:	08 95       	ret

000002d8 <Banner>:


void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 2d8:	81 e7       	ldi	r24, 0x71	; 113
 2da:	93 e0       	ldi	r25, 0x03	; 3
 2dc:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	UART_Puts(MS2);
 2e0:	8a e3       	ldi	r24, 0x3A	; 58
 2e2:	93 e0       	ldi	r25, 0x03	; 3
 2e4:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	UART_Puts(MS4);
 2e8:	88 e0       	ldi	r24, 0x08	; 8
 2ea:	93 e0       	ldi	r25, 0x03	; 3
 2ec:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
 2f0:	08 95       	ret

000002f2 <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 2f2:	82 e1       	ldi	r24, 0x12	; 18
 2f4:	93 e0       	ldi	r25, 0x03	; 3
 2f6:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
 2fa:	08 95       	ret

000002fc <LCD>:
}

void LCD(void)						//Lite LCD demo
{
 2fc:	cf 93       	push	r28
 2fe:	df 93       	push	r29
	DATA = 0x1;
 300:	81 e0       	ldi	r24, 0x01	; 1
 302:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
	LCD_Write_Command();
 306:	0e 94 74 00 	call	0xe8	; 0xe8 <LCD_Write_Command>
	DATA = 0x38;					//Student Comment Here
 30a:	88 e3       	ldi	r24, 0x38	; 56
 30c:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
	LCD_Write_Command();
 310:	0e 94 74 00 	call	0xe8	; 0xe8 <LCD_Write_Command>
	DATA = 0x08;					//Student Comment Here
 314:	88 e0       	ldi	r24, 0x08	; 8
 316:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
	LCD_Write_Command();
 31a:	0e 94 74 00 	call	0xe8	; 0xe8 <LCD_Write_Command>
	DATA = 0x02;					//Student Comment Here
 31e:	82 e0       	ldi	r24, 0x02	; 2
 320:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
	LCD_Write_Command();
 324:	0e 94 74 00 	call	0xe8	; 0xe8 <LCD_Write_Command>
	DATA = 0x06;					//Student Comment Here
 328:	86 e0       	ldi	r24, 0x06	; 6
 32a:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
	LCD_Write_Command();
 32e:	0e 94 74 00 	call	0xe8	; 0xe8 <LCD_Write_Command>
	DATA = 0x0f;
 332:	8f e0       	ldi	r24, 0x0F	; 15
 334:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
	LCD_Write_Command();
 338:	0e 94 74 00 	call	0xe8	; 0xe8 <LCD_Write_Command>
	LCD_Puts("Team Ten");
 33c:	80 e0       	ldi	r24, 0x00	; 0
 33e:	91 e0       	ldi	r25, 0x01	; 1
 340:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <LCD_Puts>
	
	ASCII = '\0';
 344:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	DATA = 0X18;
 348:	88 e1       	ldi	r24, 0x18	; 24
 34a:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
	
	while(ASCII == '\0')
	{
		UART_Inte();
 34e:	0e 94 c5 00 	call	0x18a	; 0x18a <UART_Inte>
		LCD_Write_Command();
 352:	0e 94 74 00 	call	0xe8	; 0xe8 <LCD_Write_Command>
 356:	ce e0       	ldi	r28, 0x0E	; 14
 358:	d0 e0       	ldi	r29, 0x00	; 0
		for(int i = 14;i>0;i--)
		{
			LCD_Delay();
 35a:	0e 94 86 00 	call	0x10c	; 0x10c <LCD_Delay>
 35e:	21 97       	sbiw	r28, 0x01	; 1
	
	while(ASCII == '\0')
	{
		UART_Inte();
		LCD_Write_Command();
		for(int i = 14;i>0;i--)
 360:	e1 f7       	brne	.-8      	; 0x35a <LCD+0x5e>
		{
			LCD_Delay();
		}
		UART_Inte();
 362:	0e 94 c5 00 	call	0x18a	; 0x18a <UART_Inte>
		UART_Clear();
 366:	0e 94 b5 00 	call	0x16a	; 0x16a <UART_Clear>
	LCD_Puts("Team Ten");
	
	ASCII = '\0';
	DATA = 0X18;
	
	while(ASCII == '\0')
 36a:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 36e:	88 23       	and	r24, r24
 370:	71 f3       	breq	.-36     	; 0x34e <LCD+0x52>
	Re-engineer this subroutine to have the LCD endlessly scroll a marquee sign of 
	your Team's name either vertically or horizontally. Any key press should stop
	the scrolling and return execution to the command line in Terminal. User must
	always be able to return to command line.
	*/
}
 372:	df 91       	pop	r29
 374:	cf 91       	pop	r28
 376:	08 95       	ret

00000378 <ADC>:

void ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 378:	cf 93       	push	r28
 37a:	df 93       	push	r29
	UART_Puts("\r\n");
 37c:	85 e5       	ldi	r24, 0x55	; 85
 37e:	91 e0       	ldi	r25, 0x01	; 1
 380:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	volts[0x1]='.';
 384:	c2 e9       	ldi	r28, 0x92	; 146
 386:	d3 e0       	ldi	r29, 0x03	; 3
 388:	8e e2       	ldi	r24, 0x2E	; 46
 38a:	89 83       	std	Y+1, r24	; 0x01
	volts[0x3]=' ';
 38c:	80 e2       	ldi	r24, 0x20	; 32
 38e:	8b 83       	std	Y+3, r24	; 0x03
	volts[0x4]= 0;
 390:	1c 82       	std	Y+4, r1	; 0x04
	ADC_Get();
 392:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ADC_Get>
	ASCII = HADC+ 0x30;
 396:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <HADC>
 39a:	80 5d       	subi	r24, 0xD0	; 208
 39c:	80 93 90 03 	sts	0x0390, r24	; 0x800390 <ASCII>
	UART_Put();
 3a0:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
	ASCII = LADC;
 3a4:	80 91 97 03 	lds	r24, 0x0397	; 0x800397 <LADC>
 3a8:	80 93 90 03 	sts	0x0390, r24	; 0x800390 <ASCII>
	UART_Put();
 3ac:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
	
	Acc = (((int)HADC) * 0x100 + (int)(LADC))*0xA;
 3b0:	20 91 8f 03 	lds	r18, 0x038F	; 0x80038f <HADC>
 3b4:	30 e0       	ldi	r19, 0x00	; 0
 3b6:	32 2f       	mov	r19, r18
 3b8:	22 27       	eor	r18, r18
 3ba:	80 91 97 03 	lds	r24, 0x0397	; 0x800397 <LADC>
 3be:	28 0f       	add	r18, r24
 3c0:	31 1d       	adc	r19, r1
 3c2:	c9 01       	movw	r24, r18
 3c4:	88 0f       	add	r24, r24
 3c6:	99 1f       	adc	r25, r25
 3c8:	22 0f       	add	r18, r18
 3ca:	33 1f       	adc	r19, r19
 3cc:	22 0f       	add	r18, r18
 3ce:	33 1f       	adc	r19, r19
 3d0:	22 0f       	add	r18, r18
 3d2:	33 1f       	adc	r19, r19
 3d4:	82 0f       	add	r24, r18
 3d6:	93 1f       	adc	r25, r19
	volts[0x0] = 48 + (Acc / 0x7FE);
 3d8:	ee ef       	ldi	r30, 0xFE	; 254
 3da:	f7 e0       	ldi	r31, 0x07	; 7
 3dc:	bf 01       	movw	r22, r30
 3de:	0e 94 bb 03 	call	0x776	; 0x776 <__divmodhi4>
 3e2:	26 2f       	mov	r18, r22
 3e4:	30 e3       	ldi	r19, 0x30	; 48
 3e6:	36 0f       	add	r19, r22
 3e8:	38 83       	st	Y, r19
	Acc = Acc % 0x7FE;
	volts[0x2] = ((Acc *0xA) / 0x7FE) + 48;
 3ea:	ac 01       	movw	r20, r24
 3ec:	44 0f       	add	r20, r20
 3ee:	55 1f       	adc	r21, r21
 3f0:	88 0f       	add	r24, r24
 3f2:	99 1f       	adc	r25, r25
 3f4:	88 0f       	add	r24, r24
 3f6:	99 1f       	adc	r25, r25
 3f8:	88 0f       	add	r24, r24
 3fa:	99 1f       	adc	r25, r25
 3fc:	84 0f       	add	r24, r20
 3fe:	95 1f       	adc	r25, r21
 400:	bf 01       	movw	r22, r30
 402:	0e 94 bb 03 	call	0x776	; 0x776 <__divmodhi4>
 406:	30 e3       	ldi	r19, 0x30	; 48
 408:	36 0f       	add	r19, r22
 40a:	3a 83       	std	Y+2, r19	; 0x02
	Acc = (Acc * 0xA) % 0x7FE;
 40c:	90 93 99 03 	sts	0x0399, r25	; 0x800399 <Acc+0x1>
 410:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <Acc>
	if (Acc >= 0x3FF) volts[0x2]++;
 414:	8f 3f       	cpi	r24, 0xFF	; 255
 416:	93 40       	sbci	r25, 0x03	; 3
 418:	1c f0       	brlt	.+6      	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
 41a:	6f 5c       	subi	r22, 0xCF	; 207
 41c:	60 93 94 03 	sts	0x0394, r22	; 0x800394 <volts+0x2>
	if (volts[0x2] == 58)
 420:	80 91 94 03 	lds	r24, 0x0394	; 0x800394 <volts+0x2>
 424:	8a 33       	cpi	r24, 0x3A	; 58
 426:	31 f4       	brne	.+12     	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
	{
		volts[0x2] = 48;
 428:	e2 e9       	ldi	r30, 0x92	; 146
 42a:	f3 e0       	ldi	r31, 0x03	; 3
 42c:	80 e3       	ldi	r24, 0x30	; 48
 42e:	82 83       	std	Z+2, r24	; 0x02
		volts[0x0]++;
 430:	2f 5c       	subi	r18, 0xCF	; 207
 432:	20 83       	st	Z, r18
	}
	UART_Puts(volts);
 434:	82 e9       	ldi	r24, 0x92	; 146
 436:	93 e0       	ldi	r25, 0x03	; 3
 438:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>

	UART_Puts(MS6);
 43c:	82 ee       	ldi	r24, 0xE2	; 226
 43e:	92 e0       	ldi	r25, 0x02	; 2
 440:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		The potentiometer simulates a thermistor, its varying resistance simulates the
		varying resistance of a thermistor as it is heated and cooled. See the thermistor
		equations in the lab 3 folder. User must always be able to return to command line.
	*/
	
}
 444:	df 91       	pop	r29
 446:	cf 91       	pop	r28
 448:	08 95       	ret

0000044a <Stop>:
	}
}

void Stop(void)
{
	UART_Puts("\r\n(1) bit or (2) bits\r\n");
 44a:	89 e0       	ldi	r24, 0x09	; 9
 44c:	91 e0       	ldi	r25, 0x01	; 1
 44e:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	ASCII = '\0';
 452:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 456:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>

void Stop(void)
{
	UART_Puts("\r\n(1) bit or (2) bits\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 45a:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 45e:	88 23       	and	r24, r24
 460:	d1 f3       	breq	.-12     	; 0x456 <Stop+0xc>
	{
		UART_Get();
	}
	
	switch(ASCII)
 462:	83 33       	cpi	r24, 0x33	; 51
 464:	31 f4       	brne	.+12     	; 0x472 <Stop+0x28>
	{
		
		case '1' | '2':
		ASCII = ASCII - 0x31;
 466:	82 e0       	ldi	r24, 0x02	; 2
 468:	80 93 90 03 	sts	0x0390, r24	; 0x800390 <ASCII>
		SetStop();
 46c:	0e 94 24 01 	call	0x248	; 0x248 <SetStop>
		break;
 470:	08 95       	ret
		default:
		UART_Puts(MS5);
 472:	89 ee       	ldi	r24, 0xE9	; 233
 474:	92 e0       	ldi	r25, 0x02	; 2
 476:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
 47a:	08 95       	ret

0000047c <Command>:
	}
}

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
 47c:	82 e1       	ldi	r24, 0x12	; 18
 47e:	93 e0       	ldi	r25, 0x03	; 3
 480:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	ASCII = '\0';						
 484:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 488:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 48c:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 490:	88 23       	and	r24, r24
 492:	d1 f3       	breq	.-12     	; 0x488 <Command+0xc>
	{
		UART_Get();
	}
	UART_Put();
 494:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
	switch (ASCII)
 498:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 49c:	85 36       	cpi	r24, 0x65	; 101
 49e:	79 f0       	breq	.+30     	; 0x4be <Command+0x42>
 4a0:	18 f4       	brcc	.+6      	; 0x4a8 <Command+0x2c>
 4a2:	81 36       	cpi	r24, 0x61	; 97
 4a4:	49 f0       	breq	.+18     	; 0x4b8 <Command+0x3c>
 4a6:	11 c0       	rjmp	.+34     	; 0x4ca <Command+0x4e>
 4a8:	8c 36       	cpi	r24, 0x6C	; 108
 4aa:	19 f0       	breq	.+6      	; 0x4b2 <Command+0x36>
 4ac:	85 37       	cpi	r24, 0x75	; 117
 4ae:	51 f0       	breq	.+20     	; 0x4c4 <Command+0x48>
 4b0:	0c c0       	rjmp	.+24     	; 0x4ca <Command+0x4e>
	{
		case 'L' | 'l': LCD();
 4b2:	0e 94 7e 01 	call	0x2fc	; 0x2fc <LCD>
		break;
 4b6:	08 95       	ret
		case 'A' | 'a': ADC();
 4b8:	0e 94 bc 01 	call	0x378	; 0x378 <ADC>
		break;
 4bc:	08 95       	ret
		case 'E' | 'e': EEPROM();
 4be:	0e 94 c1 02 	call	0x582	; 0x582 <EEPROM>
		break;
 4c2:	08 95       	ret
		case 'U' | 'u': UART();
 4c4:	0e 94 8c 03 	call	0x718	; 0x718 <UART>
		break;
 4c8:	08 95       	ret
		default:
		UART_Puts(MS5);
 4ca:	89 ee       	ldi	r24, 0xE9	; 233
 4cc:	92 e0       	ldi	r25, 0x02	; 2
 4ce:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		HELP();
 4d2:	0e 94 79 01 	call	0x2f2	; 0x2f2 <HELP>
 4d6:	08 95       	ret

000004d8 <ASCIItoHEX>:
	
}

void ASCIItoHEX(void)
{
	ASCII = ASCII - 0x30;
 4d8:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 4dc:	90 ed       	ldi	r25, 0xD0	; 208
 4de:	98 0f       	add	r25, r24
	if(ASCII > 9)
 4e0:	9a 30       	cpi	r25, 0x0A	; 10
 4e2:	18 f4       	brcc	.+6      	; 0x4ea <ASCIItoHEX+0x12>
	
}

void ASCIItoHEX(void)
{
	ASCII = ASCII - 0x30;
 4e4:	90 93 90 03 	sts	0x0390, r25	; 0x800390 <ASCII>
 4e8:	03 c0       	rjmp	.+6      	; 0x4f0 <ASCIItoHEX+0x18>
	if(ASCII > 9)
	{
		ASCII= ASCII -0x11;
 4ea:	81 54       	subi	r24, 0x41	; 65
 4ec:	80 93 90 03 	sts	0x0390, r24	; 0x800390 <ASCII>
	}
	if(ASCII>0x0f)
 4f0:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 4f4:	80 31       	cpi	r24, 0x10	; 16
 4f6:	58 f0       	brcs	.+22     	; 0x50e <ASCIItoHEX+0x36>
	{
		ASCII = ASCII - 0x20;
 4f8:	80 52       	subi	r24, 0x20	; 32
 4fa:	80 93 90 03 	sts	0x0390, r24	; 0x800390 <ASCII>
	}
	if(ASCII>0x0f)
 4fe:	80 31       	cpi	r24, 0x10	; 16
 500:	30 f0       	brcs	.+12     	; 0x50e <ASCIItoHEX+0x36>
	{
		UART_Puts(MS5);
 502:	89 ee       	ldi	r24, 0xE9	; 233
 504:	92 e0       	ldi	r25, 0x02	; 2
 506:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		Command();
 50a:	0e 94 3e 02 	call	0x47c	; 0x47c <Command>
 50e:	08 95       	ret

00000510 <Baud>:
	
}

void Baud(void)
{
	UART_Puts("\r\n Enter three hexadecimal values for the baud rate.\r\n");
 510:	81 e2       	ldi	r24, 0x21	; 33
 512:	91 e0       	ldi	r25, 0x01	; 1
 514:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	ASCII = '\0';
 518:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 51c:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>

void Baud(void)
{
	UART_Puts("\r\n Enter three hexadecimal values for the baud rate.\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 520:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 524:	88 23       	and	r24, r24
 526:	d1 f3       	breq	.-12     	; 0x51c <Baud+0xc>
	{
		UART_Get();
	}
	UART_Put();
 528:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
	ASCIItoHEX();
 52c:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <ASCIItoHEX>
	DATA = ASCII;
 530:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 534:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
	ASCII = '\0';
 538:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 53c:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>
	}
	UART_Put();
	ASCIItoHEX();
	DATA = ASCII;
	ASCII = '\0';
	while (ASCII == '\0')
 540:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 544:	88 23       	and	r24, r24
 546:	d1 f3       	breq	.-12     	; 0x53c <Baud+0x2c>
	{
		UART_Get();
	}
	UART_Put();
 548:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
	ASCIItoHEX();
 54c:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <ASCIItoHEX>
	DATA = (DATA<<4) + ASCII;
 550:	90 91 8e 03 	lds	r25, 0x038E	; 0x80038e <__data_end>
 554:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 558:	20 e1       	ldi	r18, 0x10	; 16
 55a:	92 9f       	mul	r25, r18
 55c:	80 0d       	add	r24, r0
 55e:	11 24       	eor	r1, r1
 560:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
	ASCII = '\0';
 564:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 568:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>
	}
	UART_Put();
	ASCIItoHEX();
	DATA = (DATA<<4) + ASCII;
	ASCII = '\0';
	while (ASCII == '\0')
 56c:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 570:	88 23       	and	r24, r24
 572:	d1 f3       	breq	.-12     	; 0x568 <Baud+0x58>
	{
		UART_Get();
	}
	UART_Put();
 574:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
	ASCIItoHEX();
 578:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <ASCIItoHEX>
	SetBaud();
 57c:	0e 94 34 01 	call	0x268	; 0x268 <SetBaud>
 580:	08 95       	ret

00000582 <EEPROM>:
	
}

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM Write and Read.");
 582:	88 e5       	ldi	r24, 0x58	; 88
 584:	91 e0       	ldi	r25, 0x01	; 1
 586:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	during run-time via the command line and the same byte of data can be read back and verified after the power to
	the Xplained Mini board has been cycled. Ask the user to enter a valid EEPROM address and an
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.*/
	
	UART_Puts("\r\nHigher 4 bits of address in hex.\r\n");
 58a:	81 e7       	ldi	r24, 0x71	; 113
 58c:	91 e0       	ldi	r25, 0x01	; 1
 58e:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	ASCII = '\0';
 592:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 596:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.*/
	
	UART_Puts("\r\nHigher 4 bits of address in hex.\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 59a:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 59e:	88 23       	and	r24, r24
 5a0:	d1 f3       	breq	.-12     	; 0x596 <EEPROM+0x14>
	{
		UART_Get();
	}
	UART_Put();
 5a2:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
	ASCIItoHEX();
 5a6:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <ASCIItoHEX>
	EEPROMAL = ASCII;
	EEPROMAL=EEPROMAL<<4;
 5aa:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 5ae:	82 95       	swap	r24
 5b0:	80 7f       	andi	r24, 0xF0	; 240
 5b2:	80 93 91 03 	sts	0x0391, r24	; 0x800391 <EEPROMAL>
	
	UART_Puts("\r\nLower 4 bits of address in hex.\r\n");
 5b6:	86 e9       	ldi	r24, 0x96	; 150
 5b8:	91 e0       	ldi	r25, 0x01	; 1
 5ba:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	ASCII = '\0';
 5be:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 5c2:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>
	EEPROMAL = ASCII;
	EEPROMAL=EEPROMAL<<4;
	
	UART_Puts("\r\nLower 4 bits of address in hex.\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 5c6:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 5ca:	88 23       	and	r24, r24
 5cc:	d1 f3       	breq	.-12     	; 0x5c2 <EEPROM+0x40>
	{
		UART_Get();
	}
	UART_Put();
 5ce:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
	ASCIItoHEX();
 5d2:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <ASCIItoHEX>
	EEPROMAL = EEPROMAL + ASCII;
 5d6:	90 91 91 03 	lds	r25, 0x0391	; 0x800391 <EEPROMAL>
 5da:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 5de:	89 0f       	add	r24, r25
 5e0:	80 93 91 03 	sts	0x0391, r24	; 0x800391 <EEPROMAL>
	
	
	UART_Puts("\r\n(S)ave or (L)oad from this address.\r\n");
 5e4:	8a eb       	ldi	r24, 0xBA	; 186
 5e6:	91 e0       	ldi	r25, 0x01	; 1
 5e8:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	ASCII = '\0';
 5ec:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 5f0:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>
	EEPROMAL = EEPROMAL + ASCII;
	
	
	UART_Puts("\r\n(S)ave or (L)oad from this address.\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 5f4:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 5f8:	88 23       	and	r24, r24
 5fa:	d1 f3       	breq	.-12     	; 0x5f0 <EEPROM+0x6e>
	{
		UART_Get();
	}
	
	switch (ASCII)
 5fc:	8c 36       	cpi	r24, 0x6C	; 108
 5fe:	99 f0       	breq	.+38     	; 0x626 <EEPROM+0xa4>
 600:	83 37       	cpi	r24, 0x73	; 115
 602:	b1 f4       	brne	.+44     	; 0x630 <EEPROM+0xae>
	{
		case 's'|'S' : 
		UART_Puts("\r\nWhat char would you like to save\r\n");
 604:	82 ee       	ldi	r24, 0xE2	; 226
 606:	91 e0       	ldi	r25, 0x01	; 1
 608:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		ASCII = '\0';
 60c:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
		while (ASCII == '\0')
		{
			UART_Get();
 610:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>
	switch (ASCII)
	{
		case 's'|'S' : 
		UART_Puts("\r\nWhat char would you like to save\r\n");
		ASCII = '\0';
		while (ASCII == '\0')
 614:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 618:	88 23       	and	r24, r24
 61a:	d1 f3       	breq	.-12     	; 0x610 <EEPROM+0x8e>
		{
			UART_Get();
		}
		EEPROM_Write();
 61c:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_Write>
		UART_Put();
 620:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
		break;
 624:	08 95       	ret
		case 'l'|'L' : 
		EEPROM_Read();
 626:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <EEPROM_Read>
		UART_Put();
 62a:	0e 94 cb 00 	call	0x196	; 0x196 <UART_Put>
		break;
 62e:	08 95       	ret
		default:
		UART_Puts(MS5);
 630:	89 ee       	ldi	r24, 0xE9	; 233
 632:	92 e0       	ldi	r25, 0x02	; 2
 634:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		Command();
 638:	0e 94 3e 02 	call	0x47c	; 0x47c <Command>
 63c:	08 95       	ret

0000063e <DataBits>:
	SetBaud();
}

void DataBits(void)
{
	UART_Puts("\r\n(5) bits, (6) bits, (7) bits, (8) bits, or (9) bits\r\n");
 63e:	87 e0       	ldi	r24, 0x07	; 7
 640:	92 e0       	ldi	r25, 0x02	; 2
 642:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	ASCII = '\0';
 646:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 64a:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>

void DataBits(void)
{
	UART_Puts("\r\n(5) bits, (6) bits, (7) bits, (8) bits, or (9) bits\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 64e:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 652:	88 23       	and	r24, r24
 654:	d1 f3       	breq	.-12     	; 0x64a <DataBits+0xc>
	{
		UART_Get();
	}
	switch(ASCII)
 656:	87 33       	cpi	r24, 0x37	; 55
 658:	a9 f0       	breq	.+42     	; 0x684 <DataBits+0x46>
 65a:	28 f4       	brcc	.+10     	; 0x666 <DataBits+0x28>
 65c:	85 33       	cpi	r24, 0x35	; 53
 65e:	d1 f0       	breq	.+52     	; 0x694 <DataBits+0x56>
 660:	86 33       	cpi	r24, 0x36	; 54
 662:	a1 f0       	breq	.+40     	; 0x68c <DataBits+0x4e>
 664:	1a c0       	rjmp	.+52     	; 0x69a <DataBits+0x5c>
 666:	88 33       	cpi	r24, 0x38	; 56
 668:	31 f0       	breq	.+12     	; 0x676 <DataBits+0x38>
 66a:	89 33       	cpi	r24, 0x39	; 57
 66c:	b1 f4       	brne	.+44     	; 0x69a <DataBits+0x5c>
	{
		case '9': DATA = 0x06;
 66e:	86 e0       	ldi	r24, 0x06	; 6
 670:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
		break;
 674:	18 c0       	rjmp	.+48     	; 0x6a6 <DataBits+0x68>
		case '8':DATA = 0x06;
 676:	86 e0       	ldi	r24, 0x06	; 6
 678:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
		ASCII = ASCII -1;
 67c:	87 e3       	ldi	r24, 0x37	; 55
 67e:	80 93 90 03 	sts	0x0390, r24	; 0x800390 <ASCII>
		break;
 682:	11 c0       	rjmp	.+34     	; 0x6a6 <DataBits+0x68>
		case '7': DATA = 0x04;
 684:	84 e0       	ldi	r24, 0x04	; 4
 686:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
		break;
 68a:	0d c0       	rjmp	.+26     	; 0x6a6 <DataBits+0x68>
		case '6': DATA = 0x02;
 68c:	82 e0       	ldi	r24, 0x02	; 2
 68e:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
		break;
 692:	09 c0       	rjmp	.+18     	; 0x6a6 <DataBits+0x68>
		case '5': DATA = 0x0;
 694:	10 92 8e 03 	sts	0x038E, r1	; 0x80038e <__data_end>
		break;
 698:	06 c0       	rjmp	.+12     	; 0x6a6 <DataBits+0x68>
		default:
		UART_Puts(MS5);
 69a:	89 ee       	ldi	r24, 0xE9	; 233
 69c:	92 e0       	ldi	r25, 0x02	; 2
 69e:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		Command();
 6a2:	0e 94 3e 02 	call	0x47c	; 0x47c <Command>
		break;
	}
	SetDataBits();
 6a6:	0e 94 0d 01 	call	0x21a	; 0x21a <SetDataBits>
 6aa:	08 95       	ret

000006ac <Parity>:
}

void Parity(void)
{
	UART_Puts("\r\n(D)isable, (E)ven, (O)dd\r\n");	
 6ac:	8f e3       	ldi	r24, 0x3F	; 63
 6ae:	92 e0       	ldi	r25, 0x02	; 2
 6b0:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	ASCII = '\0';
 6b4:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 6b8:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>

void Parity(void)
{
	UART_Puts("\r\n(D)isable, (E)ven, (O)dd\r\n");	
	ASCII = '\0';
	while (ASCII == '\0')
 6bc:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 6c0:	88 23       	and	r24, r24
 6c2:	d1 f3       	breq	.-12     	; 0x6b8 <Parity+0xc>
	{
		UART_Get();
	}
	switch(ASCII)
 6c4:	85 36       	cpi	r24, 0x65	; 101
 6c6:	69 f0       	breq	.+26     	; 0x6e2 <Parity+0x36>
 6c8:	8f 36       	cpi	r24, 0x6F	; 111
 6ca:	a9 f0       	breq	.+42     	; 0x6f6 <Parity+0x4a>
 6cc:	84 36       	cpi	r24, 0x64	; 100
 6ce:	e9 f4       	brne	.+58     	; 0x70a <Parity+0x5e>
	{
		case 'D' | 'd' : DATA = 0x00;
 6d0:	10 92 8e 03 	sts	0x038E, r1	; 0x80038e <__data_end>
		SetParity();
 6d4:	0e 94 fe 00 	call	0x1fc	; 0x1fc <SetParity>
		UART_Puts("\r\nParity Disabled\r\n");
 6d8:	8c e5       	ldi	r24, 0x5C	; 92
 6da:	92 e0       	ldi	r25, 0x02	; 2
 6dc:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		break;
 6e0:	08 95       	ret
		case 'E' | 'e' : DATA = 0x10;
 6e2:	80 e1       	ldi	r24, 0x10	; 16
 6e4:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
		SetParity();
 6e8:	0e 94 fe 00 	call	0x1fc	; 0x1fc <SetParity>
		UART_Puts("\r\nParity set to Even\r\n");
 6ec:	80 e7       	ldi	r24, 0x70	; 112
 6ee:	92 e0       	ldi	r25, 0x02	; 2
 6f0:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		break;
 6f4:	08 95       	ret
		case 'O' | 'o' : DATA = 0x18;
 6f6:	88 e1       	ldi	r24, 0x18	; 24
 6f8:	80 93 8e 03 	sts	0x038E, r24	; 0x80038e <__data_end>
		SetParity();
 6fc:	0e 94 fe 00 	call	0x1fc	; 0x1fc <SetParity>
		UART_Puts("\r\nParity set to Odd\r\n");
 700:	87 e8       	ldi	r24, 0x87	; 135
 702:	92 e0       	ldi	r25, 0x02	; 2
 704:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		break;
 708:	08 95       	ret
		default:
		UART_Puts("\r\nThis shouldn't happen\r\n");
 70a:	8d e9       	ldi	r24, 0x9D	; 157
 70c:	92 e0       	ldi	r25, 0x02	; 2
 70e:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
		Command();
 712:	0e 94 3e 02 	call	0x47c	; 0x47c <Command>
 716:	08 95       	ret

00000718 <UART>:
	
}

void UART(void)
{
	UART_Puts(MS7);
 718:	87 eb       	ldi	r24, 0xB7	; 183
 71a:	92 e0       	ldi	r25, 0x02	; 2
 71c:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
	ASCII='\0';
 720:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <ASCII>
	while (ASCII=='\0')
	{
		UART_Get();
 724:	0e 94 bc 00 	call	0x178	; 0x178 <UART_Get>

void UART(void)
{
	UART_Puts(MS7);
	ASCII='\0';
	while (ASCII=='\0')
 728:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <ASCII>
 72c:	88 23       	and	r24, r24
 72e:	d1 f3       	breq	.-12     	; 0x724 <UART+0xc>
	{
		UART_Get();
	}
	switch(ASCII)
 730:	84 36       	cpi	r24, 0x64	; 100
 732:	61 f0       	breq	.+24     	; 0x74c <UART+0x34>
 734:	18 f4       	brcc	.+6      	; 0x73c <UART+0x24>
 736:	82 36       	cpi	r24, 0x62	; 98
 738:	31 f0       	breq	.+12     	; 0x746 <UART+0x2e>
 73a:	11 c0       	rjmp	.+34     	; 0x75e <UART+0x46>
 73c:	80 37       	cpi	r24, 0x70	; 112
 73e:	49 f0       	breq	.+18     	; 0x752 <UART+0x3a>
 740:	83 37       	cpi	r24, 0x73	; 115
 742:	51 f0       	breq	.+20     	; 0x758 <UART+0x40>
 744:	0c c0       	rjmp	.+24     	; 0x75e <UART+0x46>
	{
		case 'B' | 'b' : Baud();
 746:	0e 94 88 02 	call	0x510	; 0x510 <Baud>
		break;
 74a:	08 95       	ret
		case 'D' | 'd' : DataBits();
 74c:	0e 94 1f 03 	call	0x63e	; 0x63e <DataBits>
		break;
 750:	08 95       	ret
		case 'P' | 'p' : Parity();
 752:	0e 94 56 03 	call	0x6ac	; 0x6ac <Parity>
		break;
 756:	08 95       	ret
		case 'S' | 's' : Stop();
 758:	0e 94 25 02 	call	0x44a	; 0x44a <Stop>
		break;
 75c:	08 95       	ret
		default:
		UART_Puts(MS5);
 75e:	89 ee       	ldi	r24, 0xE9	; 233
 760:	92 e0       	ldi	r25, 0x02	; 2
 762:	0e 94 4a 01 	call	0x294	; 0x294 <UART_Puts>
 766:	08 95       	ret

00000768 <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 768:	0e 94 53 00 	call	0xa6	; 0xa6 <Mega328P_Init>
	Banner();
 76c:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <Banner>
	while (1)
	{
		Command();				//infinite command loop
 770:	0e 94 3e 02 	call	0x47c	; 0x47c <Command>
 774:	fd cf       	rjmp	.-6      	; 0x770 <main+0x8>

00000776 <__divmodhi4>:
 776:	97 fb       	bst	r25, 7
 778:	07 2e       	mov	r0, r23
 77a:	16 f4       	brtc	.+4      	; 0x780 <__divmodhi4+0xa>
 77c:	00 94       	com	r0
 77e:	07 d0       	rcall	.+14     	; 0x78e <__divmodhi4_neg1>
 780:	77 fd       	sbrc	r23, 7
 782:	09 d0       	rcall	.+18     	; 0x796 <__divmodhi4_neg2>
 784:	0e 94 cf 03 	call	0x79e	; 0x79e <__udivmodhi4>
 788:	07 fc       	sbrc	r0, 7
 78a:	05 d0       	rcall	.+10     	; 0x796 <__divmodhi4_neg2>
 78c:	3e f4       	brtc	.+14     	; 0x79c <__divmodhi4_exit>

0000078e <__divmodhi4_neg1>:
 78e:	90 95       	com	r25
 790:	81 95       	neg	r24
 792:	9f 4f       	sbci	r25, 0xFF	; 255
 794:	08 95       	ret

00000796 <__divmodhi4_neg2>:
 796:	70 95       	com	r23
 798:	61 95       	neg	r22
 79a:	7f 4f       	sbci	r23, 0xFF	; 255

0000079c <__divmodhi4_exit>:
 79c:	08 95       	ret

0000079e <__udivmodhi4>:
 79e:	aa 1b       	sub	r26, r26
 7a0:	bb 1b       	sub	r27, r27
 7a2:	51 e1       	ldi	r21, 0x11	; 17
 7a4:	07 c0       	rjmp	.+14     	; 0x7b4 <__udivmodhi4_ep>

000007a6 <__udivmodhi4_loop>:
 7a6:	aa 1f       	adc	r26, r26
 7a8:	bb 1f       	adc	r27, r27
 7aa:	a6 17       	cp	r26, r22
 7ac:	b7 07       	cpc	r27, r23
 7ae:	10 f0       	brcs	.+4      	; 0x7b4 <__udivmodhi4_ep>
 7b0:	a6 1b       	sub	r26, r22
 7b2:	b7 0b       	sbc	r27, r23

000007b4 <__udivmodhi4_ep>:
 7b4:	88 1f       	adc	r24, r24
 7b6:	99 1f       	adc	r25, r25
 7b8:	5a 95       	dec	r21
 7ba:	a9 f7       	brne	.-22     	; 0x7a6 <__udivmodhi4_loop>
 7bc:	80 95       	com	r24
 7be:	90 95       	com	r25
 7c0:	bc 01       	movw	r22, r24
 7c2:	cd 01       	movw	r24, r26
 7c4:	08 95       	ret

000007c6 <_exit>:
 7c6:	f8 94       	cli

000007c8 <__stop_program>:
 7c8:	ff cf       	rjmp	.-2      	; 0x7c8 <__stop_program>
